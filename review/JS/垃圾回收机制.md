## GC
明确了GC做什么了：

- 找到内存空间中的垃圾。
- 回收垃圾，让程序员能再次利用这部分空间。
## V8 回收策略
新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用 不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件时，会被移动到老生代（晋升）。
## 新生代到老生代转化条件
- 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。
- **To 空间的对象占比大小超过 25 %。** 在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。
## 新生代算法
在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 结束
![image](https://segmentfault.com/img/remote/1460000019584490?w=560&h=361)
## 老生代算法
### 引用计数
顾名思义：跟踪记录每个值被引用的次数
```js
var a = new Object(); // 此时'这个对象'的引用计数为1（a在引用）
var b = a; // ‘这个对象’的引用计数是2（a,b）
a = null; // reference_count = 1
b = null; // reference_count = 0 
// 下一步 GC来回收‘这个对象’了

```
**优势**
- **引用数值为0可即刻回收垃圾**
- 因为是即时回收,那么‘程序’不会暂停去单独使用很长一段时间的GC，那么最大暂停时间很短。
- 不用去遍历堆里面的所有活动对象和非活动对象

**缺点**
- 计数器需要占很大的位置
- 无法解决循环引用问题

> 该算法已经逐渐被 ‘标记-清除’ 算法替代，在V8引擎里面，使用最多的就是 标记-清除算法
### 标记清除算法
变量进入环境，标记为进入环境；离开环境，标记为离开环境。

垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

