### 函数中的 arguments 是数组吗？若不是，如何将它转化为真正的数组 

不是

类数组转数组方法

-  Array.from(arguments)
-  Array.prototype.slice.call (arguments)

- [].slice.call(arguments)

###  请说出以下代码打印的结果 

```js
if ([] == false) {console.log(1);};
if ({} == false ) {console.log(2);};
if ([]) {console.log(3);};
if ([1] == [1]) {console.log(4);};
```

==宽松相等会发生隐式类型转换，在本题中，

```js
一、[]==false
1.存在object, 转化为原始值
ToPrimitive([]); // ''

2.一个string， 另外为boolean,都转为number
Number('');//0
Number(false);//0

3.return 0 == 0;/true
{} == false

二、{}==false
1. 存在object，转换为原始值
	"[object Object]"
2. 一个string一个Boolean，转number
Number("[object Object]")//NaN
Number(false)//0
3 return NaN==0 //fasle
三、[]
转boolean时，除了假值，全为真 
假值：null、undefined、""（空字符串）、+0、-0、NaN
所以weitrue
四、[1]==[1]
宽松相等两侧类型相同时，返回===的结果，在这里，我猜是因为两者引用的不是同一块内存，故false
```

###  使用JS实现一个repeat方法，调用这个 repeatedFunc("hellworld")，会alert4次 helloworld, 每次间隔3秒 

```js
function repeat(func, times, wait) {
}
const repeatFunc = repeat(alert, 4, 3000)
```

```js
function repeat(func, times, delay) {
  return msg => {
    let timer = setTimeout(() => {
      times-- > 0 ? func(msg) : clearTimeout(timer)
    }, delay)
  }
}
```

###  0.1+0.2===0.3吗，为什么？ 

 因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。 

64位中，1位符号位，整数位11位，小数占52位。 因为 `0.1` 和 `0.2` 都是无限循环的二进制了，所以在小数位末尾处需要判断是否进位（就和十进制的四舍五入一样）。 发生了精度损失。

#### 解决办法

```js
parseFloat((0.1 + 0.2).toFixed(10))
```

### Number()的存储空间是多大，如果后台发送了一个超过最大字节的数字怎们办 



 Number类型的数字在内存中会被表示成：`s x m x 2^e`这样的格式。 

其中符号位s占1位，指数为e占11位，m占52位。

```js
Number.MIN_SAFE_INTEGER==-Math.pow(2,53)+1//true
Number.MAX_SAFE_INTEGER==Math.pow(2,53)-1//true
```

Number的存储空间为2的53次方

> 为什么多了一位？
>
>  这是因为二进制表示有效数字总是1.xx…xx的形式，尾数部分f在规约形式下第一位默认为1（省略不写，xx..xx为尾数部分f，最长52位）。因此，JavaScript提供的有效数字最长为53个二进制位（64位浮点的后52位+被省略的1位）
>

